<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Writing mikutter plugin</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="title" content="Writing mikutter plugin"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content=""/>
<meta name="author" content="@toshi_a"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  {margin-left:auto; margin-right:0px;  text-align:right;}
  .left   {margin-left:0px;  margin-right:auto; text-align:left;}
  .center {margin-left:auto; margin-right:auto; text-align:center;}
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top;  }
  th.right  { text-align:center;  }
  th.left   { text-align:center;   }
  th.center { text-align:center; }
  td.right  { text-align:right;  }
  td.left   { text-align:left;   }
  td.center { text-align:center; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  div.inlinetask {
    padding:10px;
    border:2px solid gray;
    margin:10px;
    background: #ffffcc;
  }
  textarea { overflow-x: auto; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>

</head>
<body>

<div id="preamble">

</div>

<div id="content">
<h1 class="title">Writing mikutter plugin</h1>


<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 はじめに</a>
<ul>
<li><a href="#sec-1-1">1.1 想定する読者</a></li>
<li><a href="#sec-1-2">1.2 プラグインの動かし方</a></li>
<li><a href="#sec-1-3">1.3 プラグインの作成支援機能</a>
<ul>
<li><a href="#sec-1-3-1">1.3.1 雛形の作成(generate)</a></li>
<li><a href="#sec-1-3-2">1.3.2 定義ファイルの作成(spec)</a></li>
</ul>
</li>
<li><a href="#sec-1-4">1.4 準備はできた？</a></li>
</ul>
</li>
<li><a href="#sec-2">2 特定の時間にツイートする</a>
<ul>
<li><a href="#sec-2-1">2.1 コード</a></li>
<li><a href="#sec-2-2">2.2 解説</a>
<ul>
<li><a href="#sec-2-2-1">2.2.1 メソッドの定義</a></li>
<li><a href="#sec-2-2-2">2.2.2 文字列を投稿する</a></li>
<li><a href="#sec-2-2-3">2.2.3 Reserver 予約実行</a></li>
</ul>
</li>
<li><a href="#sec-2-3">2.3 まとめ</a></li>
</ul>
</li>
<li><a href="#sec-3">3 特殊なタイムライン</a>
<ul>
<li><a href="#sec-3-1">3.1 コード</a></li>
<li><a href="#sec-3-2">3.2 解説</a>
<ul>
<li><a href="#sec-3-2-1">3.2.1 イベントの待受</a></li>
<li><a href="#sec-3-2-2">3.2.2 タブとタイムライン</a></li>
</ul>
</li>
<li><a href="#sec-3-3">3.3 まとめ</a></li>
</ul>
</li>
<li><a href="#sec-4">4 キーワードミュート機能</a>
<ul>
<li><a href="#sec-4-1">4.1 コード</a></li>
<li><a href="#sec-4-2">4.2 解説</a>
<ul>
<li><a href="#sec-4-2-1">4.2.1 イベントフィルタ</a></li>
</ul>
</li>
<li><a href="#sec-4-3">4.3 まとめ</a></li>
</ul>
</li>
<li><a href="#sec-5">5 STOT形式でコピー</a>
<ul>
<li><a href="#sec-5-1">5.1 コード</a></li>
<li><a href="#sec-5-2">5.2 解説</a>
<ul>
<li><a href="#sec-5-2-1">5.2.1 STOTについて</a></li>
<li><a href="#sec-5-2-2">5.2.2 mikutterコマンド</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-6">6 システムメッセージの利用</a>
<ul>
<li><a href="#sec-6-1">6.1 コード</a></li>
<li><a href="#sec-6-2">6.2 解説</a>
<ul>
<li><a href="#sec-6-2-1">6.2.1 アクティビティとは</a></li>
<li><a href="#sec-6-2-2">6.2.2 通知の種類</a></li>
<li><a href="#sec-6-2-3">6.2.3 実際に通知を発生させる</a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-7">7 終わりに</a>
<ul>
<li><a href="#sec-7-1">7.1 プラグインを公開する</a></li>
<li><a href="#sec-7-2">7.2 他のドキュメント</a></li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> はじめに</h2>
<div class="outline-text-2" id="text-1">

<p>  Rubyでmikutterを拡張する方法についてです。
</p>
<p>
  mikutterはサードパーティの「プラグイン」を追加して、あとから機能を追
  加することができます。
</p>
<p>
  本文章では、いくつかの事例を取り上げて、プラグインを作るための大まかな方
  法を説明します。
</p>
<p>
  サンプルコードは、 <a href="https://github.com/toshia/writing-mikutter-plugin">https://github.com/toshia/writing-mikutter-plugin</a> にこのドキュメントの最新版があるので、そこから取得してください。
</p>

</div>

<div id="outline-container-1-1" class="outline-3">
<h3 id="sec-1-1"><span class="section-number-3">1.1</span> 想定する読者</h3>
<div class="outline-text-3" id="text-1-1">

<p>   一応、これを読むような人は大抵プログラミングの経験があると思いますが、何らかの言語を理解している人なら、Rubyを勉強しながら簡単にプラグインを書くことができると思います。
   基本的なプログラミングの概念については説明していません。世の中にはRubyでプログラミングを学ぶことができる文献がいくつもありますので、プログラミング自体の話はそういうのをどうぞ。
</p>
</div>

</div>

<div id="outline-container-1-2" class="outline-3">
<h3 id="sec-1-2"><span class="section-number-3">1.2</span> プラグインの動かし方</h3>
<div class="outline-text-3" id="text-1-2">

<p>   mikutterのプラグインをインストールするには、 ~/.mikutter/plugin の直下に拡張子 <b>.rb</b> で終わるファイルを置くか、
   プラグイン名のディレクトリを作成し、その中に <b>プラグイン名.rb</b> という名前のファイルを設置する方法があります。
   後者の方法を使うと、gitなどでプラグインごとにバージョン管理が容易になりますし、プラグイン自体を複数のファイルに分割することができます。
</p>
</div>

</div>

<div id="outline-container-1-3" class="outline-3">
<h3 id="sec-1-3"><span class="section-number-3">1.3</span> プラグインの作成支援機能</h3>
<div class="outline-text-3" id="text-1-3">

<p>   mikutterにはプラグインの作成を支援する機能があります。mikutter.rbにはいくつかのコマンドラインオプションがあります。
</p>
<pre class="example">
$ mikutter.rb --help
command are:
    generate [plugin_slug]       generate plugin template at ~/.mikutter/plugin/
    spec [directory]             generate plugin spec. ex) mikutter spec ~/.mikutter/plugin/test
</pre>



</div>

<div id="outline-container-1-3-1" class="outline-4">
<h4 id="sec-1-3-1"><span class="section-number-4">1.3.1</span> 雛形の作成(generate)</h4>
<div class="outline-text-4" id="text-1-3-1">

<p>    プラグインを新しく作成するときに、以下の様なコマンドを実行すれば必要なディレクトリを作成し、ひな形ファイルを作成します。
</p>
<pre class="example">
$ mikutter.rb generate test_plugin
</pre>


<p>
    これで、 ~/.mikutter/plugin/test_plugin/ ディレクトリが作成され、その中に test_plugin.rb というファイルが作成されます。また、このファイルには最低限のプラグインのテンプレートが書かれています。
</p>



<pre class="example"># -*- coding: utf-8 -*-

Plugin.create(:test_plugin) do

end
</pre>


</div>

</div>

<div id="outline-container-1-3-2" class="outline-4">
<h4 id="sec-1-3-2"><span class="section-number-4">1.3.2</span> 定義ファイルの作成(spec)</h4>
<div class="outline-text-4" id="text-1-3-2">

<p>    mikutter 0.2からはプラグインに定義ファイルを持たせることが推奨されています。定義ファイルは、プラグインの説明、バージョン、作者、依存関係などの情報を含むファイルで、なければ不適切な環境でプラグインがロードされ、クラッシュするおそれがあります。書式を長々と説明するよりも、これも自動的に生成させることができます。
</p>
<pre class="example">
$ mikutter.rb spec ~/.mikutter/plugin/test_plugin/
</pre>


<p>
    引数には、プラグインのスラッグではなく、ディレクトリパスを与えることに注意してください。これを実行すると、対話的に２，３質問されるので、適当に答えましょう。すると、 ~/.mikutter/plugin/test_plugin/spec というファイルが生成されるはずです。
    test_pluginは何も内容がないので、specファイルも見所がありません。みっくストア(<a href="https://github.com/toshia/mikustore">https://github.com/toshia/mikustore</a>)のspecファイルがこの方法で生成されているので、ちょっと見てみましょう。
</p>



<pre class="example">---
slug: :mikustore
depends:
  mikutter: 0.2.0.1051
  plugin:
  - settings
version: '0.1'
author: toshi_a
name: みっくストア
description: mikutterにプラグインのパッケージ管理機能を追加します。みっくストアに登録されているプラグインはクリックだけでダウンロードできます！
</pre>


<p>
     適切な情報が自動的にspecファイルに書き込まれました。もう一度、specファイルを作成するコマンドを実行してみましょう。今度は何も聞かれずにすぐにコマンドが終了してしまったはずです。というのも、対話プロンプトで入力されるような内容は、既に存在するspecファイルに書かれているからです。二度目以降は、依存関係などを更新するだけとなります。
</p>
</div>
</div>

</div>

<div id="outline-container-1-4" class="outline-3">
<h3 id="sec-1-4"><span class="section-number-3">1.4</span> 準備はできた？</h3>
<div class="outline-text-3" id="text-1-4">

<p>   プラグインを作成する準備は整いました。早速、いくつかのサンプルプラグインを見ながら、お気に入りのエディタを起動して、mikutterをハックしましょう。
</p>
</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><span class="section-number-2">2</span> 特定の時間にツイートする</h2>
<div class="outline-text-2" id="text-2">

<p>  このセクションでは、特定の時間に定型文をツイートする、botのようなプラグインを作成します。
</p>
</div>

<div id="outline-container-2-1" class="outline-3">
<h3 id="sec-2-1"><span class="section-number-3">2.1</span> コード</h3>
<div class="outline-text-3" id="text-2-1">




<pre class="example"># -*- coding: utf-8 -*-
# say "よるほー"
# よるほーの例です。あくまでReserverのデモンストレーション用に作りました。
# なので実戦投入はしないこと。よるほーは自分でタイミングを合わせることにこそ意義があるのです。

Plugin.create :yoruho do
  def main
    Reserver.new(nextyrhtime){
      say_yoruho(Service.primary)
      sleep 1
      main } end

  # 次回のよるほー時間を取得
  def nextyrhtime
    now = Time.new
    result = Time.local(now.year, now.month, now.day, 0, 0)
    while result &lt; now
      result += 86400 end
    result end

  # よるほーとつぶやく
  def say_yoruho(service)
    service.update(:message =&gt; 'ておほー') end

  main
end
</pre>


</div>

</div>

<div id="outline-container-2-2" class="outline-3">
<h3 id="sec-2-2"><span class="section-number-3">2.2</span> 解説</h3>
<div class="outline-text-3" id="text-2-2">

<p>   ほぼすべてのプラグインは、以下のテンプレートから作り始めることになります。
</p>
<pre class="example">
Plugin.create :プラグイン名 do
  (プラグインの定義)
end
</pre>


<p>
   Plugin.create は、プラグインをコアに登録します。また、ブロック内でプラグインを実装するための様々なメソッドを提供しています。
   この中で変数や関数を定義すれば外のスコープも汚さないので、基本的にはこのブロックの中だけでプラグインは完結させるべきです。
</p>

</div>

<div id="outline-container-2-2-1" class="outline-4">
<h4 id="sec-2-2-1"><span class="section-number-4">2.2.1</span> メソッドの定義</h4>
<div class="outline-text-4" id="text-2-2-1">

<p>    ブロックの中は、すぐにPluginのインスタンスの中で評価されます。defで
    メソッドを定義して、メソッドの内外で呼ぶことができます。例では main
    と next_yrh_time と say_yoruho を定義していますね。
</p>
</div>

</div>

<div id="outline-container-2-2-2" class="outline-4">
<h4 id="sec-2-2-2"><span class="section-number-4">2.2.2</span> 文字列を投稿する</h4>
<div class="outline-text-4" id="text-2-2-2">

<ul>
<li id="sec-2-2-2-1">Serviceオブジェクト<br/>
     自動投稿を実現するためには、Serviceクラスのインスタンスを得ます。
     Serviceクラスは、Twitter APIのラッパで、ログインしているTwitterアカウ
     ントの数だけインスタンスがあります。なので、プラグインがこのクラス
     をnewすることはありません。

<p>
     これを書いている現在では、mikutterは１つのアカウントでしかサインアッ
     プできないということになっているので、以下のように書けば、Serviceクラ
     スを得ることができると覚えておいてください。
</p>
<pre class="example">
Service.primary
</pre>


<p>
     mikutterはそのうち複垢対応しますが、そうなったらこのメソッドは、現
     在アクティブな(選択されている)アカウントのServiceを返します。
</p>
</li>
</ul>
<ul>
<li id="sec-2-2-2-2">update<br/>
     Service#update で、ツイートが投稿されます。

<pre class="example">
Service.primary.update(:message =&gt; "ツイートの本文")
</pre>


<p>
     ツイートの投稿は非同期で行われるので、処理がここで止まるというこ
     とはありません。
</p>
</li>
</ul>
</div>

</div>

<div id="outline-container-2-2-3" class="outline-4">
<h4 id="sec-2-2-3"><span class="section-number-4">2.2.3</span> Reserver 予約実行</h4>
<div class="outline-text-4" id="text-2-2-3">

<p>    特定の時間に処理を実行したいことがあります。今回の場合だと、毎日
    0:00:00に、よるほーとつぶやくコードを実行したいわけです。そういう
    時は、mikutterが提供しているReserverを使います。
</p>
<p>
    String, Time, Integerのいずれかの値を渡します。
</p>
<p>
    Stringの場合はTime.parse()された値が使われ、Timeを渡すと、その時刻
    になったら実行します。過去の時刻を渡すとすぐに実行されます。
</p>
<pre class="example">
Reserver.new("10:00"){ 朝10時に実行 }
</pre>


<p>
    Integerの場合は、その秒数待ってから実行します。
</p>
<pre class="example">
Reserver.new(30){ 30秒後に実行 }
Reserver.new(HYDE){ 156秒後に実行 }
</pre>


<p>
    今のところ、Reserverのブロックは、メインスレッド <b>以外</b> のスレッドで実
    行されます。非同期処理によるバグには気をつけてください。
</p>
</div>
</div>

</div>

<div id="outline-container-2-3" class="outline-3">
<h3 id="sec-2-3"><span class="section-number-3">2.3</span> まとめ</h3>
<div class="outline-text-3" id="text-2-3">

<p>   ReserverとService#postについて学びました。
   Service.primary.post() でツイートの投稿ができます。
   Reserverは特定の時間に処理を実行するためのクラスです。
</p>
</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> 特殊なタイムライン</h2>
<div class="outline-text-2" id="text-3">

<p>  現在のmikutterのUIは、以下のような構成です。
</p>
<p>
  <img src="window-hierarchy.png"  alt="window-hierarchy.png" />
</p>
<p>
  ウィンドウが一つ有り、その中にユーザは任意の個数のペインを作ります。
  ペインの中には１つ以上のタブがあり、タブの中身はプラグイン次第です
  が、基本的にはタイムラインが入っているはずです。
</p>
<p>
  このセクションでは、特殊な抽出条件を持ったタイムラインを作成します。
  タイムラインを用いたあらゆるプラグインに応用できる知識です。
</p>

</div>

<div id="outline-container-3-1" class="outline-3">
<h3 id="sec-3-1"><span class="section-number-3">3.1</span> コード</h3>
<div class="outline-text-3" id="text-3-1">





<pre class="example"># -*- coding: utf-8 -*-
# mikutterについてフォロイーが言及したら、しばらくTLに入れる

Plugin.create :gossip_detector do

  EXPIRE = 300                  # 5 min

  gossip_users = {}

  tab :gossip_detector, 'Gossip Detector' do
    set_icon MUI::Skin.get("timeline.png")
    timeline :gossip_detector
  end

  # ツイートの受信、振り分け
  onupdate do |service, messages|
    timeline(:gossip_detector) &lt;&lt; message.select { |m|
      if m.to_s =~ /mikutter|みくった/
        gossip_users[m.user] = Time.now + EXPIRE
        true
      else
        gossip_users.has_key?(m.user) and gossip_users[m.user] &gt; m[:created]
      end
    }
  end

end

</pre>


</div>

</div>

<div id="outline-container-3-2" class="outline-3">
<h3 id="sec-3-2"><span class="section-number-3">3.2</span> 解説</h3>
<div class="outline-text-3" id="text-3-2">

<p>   このプラグインは、タイムラインをひとつ作って、フォロイーが mikutter に
   ついて何か言及したら、そのツイートをそのタイムラインにも表示します。
   これだけだと、現在 mikutter に標準で入っている extract plugin と同じで
   すが、このプラグインはその人のツイートを、マッチしたツイートから5分間
   の間は、無条件にタイムラインに入れます。
</p>
<p>
   最初に mikutter の名前を出して、あとでツイートを小分けにして mikutter
   について言及しているかもしれないからです。そんなことないかもしれませんが、こんな変なフィルタも書けるんだよというデモなので勘弁して下さい。
</p>

</div>

<div id="outline-container-3-2-1" class="outline-4">
<h4 id="sec-3-2-1"><span class="section-number-4">3.2.1</span> イベントの待受</h4>
<div class="outline-text-4" id="text-3-2-1">

<p>    ユーザやTwitterから何かしらの入力があれば、mikutter内ではイベントが発
    生します。ほとんどのプラグインは、このイベントを受け取って何かを実行す
    ることで、目的を達成します。
    Plugin.create のブロック内に、以下のように書けば、イベント <b>event</b> が
    発生したときに <b>処理</b> が実行されます。その際、引数は <b>params</b> にセット
    されます。
</p>



<pre class="example">onevent do |params|
  # 処理
end
</pre>


<p>
    <b>onevent</b> は、 <b>on_event</b> と書いても <b>event</b> を待ち受けます。イベ
    ント名が長いなど、つなげて書くと読みづらい場合は、間にアンダーバー
    を入れるパターンを使ってもいいかもしれません。
    引数は、イベントによって異なります。 mikutter プラグインの開発にとって
    イベントはとても重要なものですが、数が多いので、このあと出てくるぶんに
    ついても逐一解説はしません。各イベントについて知りたい場合は、RDocの
    イベント・フィルタリファレンス <a href="http://mikutter.hachune.net/rdoc/Plugin.html">http://mikutter.hachune.net/rdoc/Plugin.html</a> を参照してください。ただし、これが
    mikutterのすべてのイベントを網羅しているわけではありません。プラグ
    インが新しい種類のイベントを定義することができるからです。
</p>
</div>

</div>

<div id="outline-container-3-2-2" class="outline-4">
<h4 id="sec-3-2-2"><span class="section-number-4">3.2.2</span> タブとタイムライン</h4>
<div class="outline-text-4" id="text-3-2-2">

<p>    UIの定義を見てみましょう。このプラグインは、一つのタブを追加して、そのなかに一つのタイムラインがあるという、最も標準的なUIを持っています。
    タブを作成するには、tabメソッドを使います。
</p>



<pre class="example">tab :gossip_detector, "Gossip Detector"
</pre>


<p>
    第一引数はタブを区別するための一意な名前、第二引数はタイトル、具体的にはタブにフォーカスを合わせた時に出てくるチップヘルプのテキストを指定します。これだけでタブは表示されます。次にタイムラインを用意しましょう。上のコードにブロックを与え、少しばかりコードをかいてやります。
</p>



<pre class="example">tab :gossip_detector, 'Gossip Detector' do
  set_icon MUI::Skin.get("timeline.png")
  timeline :gossip_detector
end
</pre>


<p>
    タイムラインを作成しているのは三行目です。引数はタイムラインを識別するための一意な名前です。例ではタブと衝突していますが、タブとタイムラインのように、種類が違うウィジェットの名前がかぶっても問題ありません。
    二行目のset_iconは、タブのアイコンを設定しています。画像ファイルへのパスか、Web上のURLを使用することもできます。
</p>
<ul>
<li id="sec-3-2-2-1">タイムラインにツイートを追加する<br/>
     作成したタイムラインを表示することは出来ました。次に、ツイートを
     タイムラインに追加する方法です。これは簡単です。




<pre class="example">timeline(:gossip_detector) &lt;&lt; Message
</pre>


<p>
     timelineメソッドに先ほど作成した時と同じ名前を指定してやれば、タイムラインのインターフェイスオブジェクトが取得できます。
     それに&lt;&lt;演算子で、Messageかその配列を渡せばそのツイートをタイムラインに追加できます。
</p>
<p>
     Messageについては、結構複雑なので後述します。今回の例では、 
     Message#user を使って、ツイートしたユーザを取得しているのと、
     Message#[] の <b>:created</b> (投稿日時)を取得しています。
</p>
<p>
     この情報を元に、mikutterの言及があれば今後5分間だけツイートを抽出
     するフィルタを実現できるわけです。
     少し実装を変えれば、他のツイッタークライアントではできないような
     複雑なフィルタを比較的簡単に実装することができるでしょう。
</p>
</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-3-3" class="outline-3">
<h3 id="sec-3-3"><span class="section-number-3">3.3</span> まとめ</h3>
<div class="outline-text-3" id="text-3-3">

<p>   イベントと、タイムラインの作り方について学びました。
   イベントは、onXXXで定義し、mikutterやプラグインが発生させたイベントをトリガーに起動します。
   tabはタブの作成、timelineはタイムライン作成のメソッドです。
   既に作成したタブやタイムラインと同じ名前を指定すると、既に存在するオブジェクトが取得できます。
</p>
</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> キーワードミュート機能</h2>
<div class="outline-text-2" id="text-4">

<p>  mikutter標準のミュート機能は、すべてのタイムラインからツイートを非表示にします。このセクションでは、キーワードミュートを実現するために、イベントが発生する前にその内容を編集・削除するためのイベントフィルタ機能、またそれを単体で使って、プラグイン間通信を実現する方法について解説します。
</p>

</div>

<div id="outline-container-4-1" class="outline-3">
<h3 id="sec-4-1"><span class="section-number-3">4.1</span> コード</h3>
<div class="outline-text-3" id="text-4-1">

<p>   今回は、特定の単語の入ったツイートを非表示にします。
</p>


<pre class="example"># -*- coding: utf-8 -*-

Plugin.create(:mute_word) do

  exclude_words = ["政治","原発"] # フィルタする単語

  filter_show_filter do |msgs|
    msgs = msgs.select{ |m| not exclude_words.any?{ |word| m.to_s.include?(word) } }
    [msgs]
  end

end
</pre>


</div>

</div>

<div id="outline-container-4-2" class="outline-3">
<h3 id="sec-4-2"><span class="section-number-3">4.2</span> 解説</h3>
<div class="outline-text-3" id="text-4-2">


</div>

<div id="outline-container-4-2-1" class="outline-4">
<h4 id="sec-4-2-1"><span class="section-number-4">4.2.1</span> イベントフィルタ</h4>
<div class="outline-text-4" id="text-4-2-1">

<ul>
<li id="sec-4-2-1-1">イベントの引数を編集する<br/>
     プラグインがツイートを取得するためにイベントを使用していることは前のセクションで触れました。今回は、イベントの発生時にそれを捕まえて、引数を書き換えることができる「イベントフィルタ」を使用します。

<p>
     フィルタは、Plugin.createのブロック内で以下のように宣言します。
</p>



<pre class="example">filter_update do |service, msgs|
  msgs = msgs.select{ |m| not m.to_s.include?("政治") }
  [service, msgs]
end
</pre>


<p>
     イベントが発生すると、イベントと同じ名前のフィルタが登録されていな
     いか確認して、登録されていたら先にフィルタを実行し、その戻り値を新
     たに引数リストにします。なので、普通のイベントと同じように引数を受
     け取り、加工した結果を返すことで、イベントの引数を変更できます。
</p>
<p>
     この場合は、updateイベントで配送されるツイートをすべて確認して、
     「政治」「原発」というキーワードが含まれたツイートを削除します。
     三行目が戻り値ですが、ここに注目してください。引数を配列で返してい
     ます。こうやって、加工した値を返してやることで、実際にイベントが発
     生する時には、該当するツイートが除外されるようになるわけです。
</p>
<p>
     一つ注意しなければいけないのは、戻り値の配列は、必ず引数の数と一
     致しなければいけないということです。なぜなら、イベントの引数の数
     は、今のところ常に固定だからです。
</p>
</li>
</ul>
<ul>
<li id="sec-4-2-1-2">イベントフィルタを使ったプラグイン間の通信<br/>
     イベントを使えば、別のプラグインに情報を伝えることができるという
     のは前に紹介したとおりです。

<p>
     しかし、イベントは受け取りたい方がイベントを待ち受けて、発信されるのを待つ必要があります。
     実際には受け取り側のリクエストに即座に答えるような通信をしたいことのほうが多いと思われますが、
     こういった用途にもイベントフィルタを使用します。
</p>
<p>
     まず、イベントフィルタは、イベントが発生していなくても単独で呼び出すことができます。
</p>
<pre class="example">
Plugin.filtering(:update, Post.primary_service, [Instance of Messages...])
</pre>


<p>
     この戻り値は、[Post, [Message&hellip;]]のような、イベントフィルタの戻
     り値そのままです。
</p>
<p>
     次に、イベントフィルタは、イベントが未定義でも作成できます。
</p>



<pre class="example">filter_plus do |num|
  [num + 1]
end
</pre>


<p>
     つまり、直接呼び出されることだけを想定したフィルタを勝手に定義し
     てしまえば、リクエスト-レスポンス型の通信が実現できるのです。
</p>
<ul>
<li id="sec-4-2-1-2-1">mikutterから完全に排除するには<br/>
      実は、updateイベントのフィルタでは、ホームタイムラインから表示さ
      れなくなるだけで、他のタイムラインからはフィルタリングできていま
      せん。この実装のほうがいい場合もあるでしょうが、mikutter上にそも
      そも表示されないようにしたい場合もあると思います。

<p>
      そのためには、タイムラインが表示前にフィルタを呼び出していれば、
      そこで削除することができますね。当然、mikutterはミュートを実現す
      るために、表示する寸前に以下のようなコードでフィルタを呼び出して
      います。
</p>
<pre class="example">
Plugin.filtering(:show_filter, message)
</pre>


<p>
      つまり、前に書いたupdateフィルタは以下のように書き換えれば、すべ
      てのタイムラインに影響するようになります。
</p>



<pre class="example">filter_show_filter do |msgs|
  msgs = msgs.select{ |m| not m.to_s.include?("政治") }
  [msgs]
end
</pre>


<p>
      show_filterは、notifyプラグインからも使用されていて、TLに表示さ
      れないツイートはポップアップ通知や効果音も鳴らさないようになって
      います。こんなふうに、他のプラグインが他の用途のためのフィルタを
      使用したり、コールバックを登録することもできます。イベントとフィ
      ルタをうまく使えば、プラグインそれ自身に拡張性を持たせることがで
      きます。
</p>
</li>
</ul>
</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-4-3" class="outline-3">
<h3 id="sec-4-3"><span class="section-number-3">4.3</span> まとめ</h3>
<div class="outline-text-3" id="text-4-3">

<p>   イベントフィルタについて学びました。
   filter_XXX でフィルタを作成し、Plugin.filteringでそれらを利用することができます。
</p>
</div>
</div>

</div>

<div id="outline-container-5" class="outline-2">
<h2 id="sec-5"><span class="section-number-2">5</span> STOT形式でコピー</h2>
<div class="outline-text-2" id="text-5">

<p>  STOT(ShareTwitterOnTumblr)は、ツイートをTumblrに投稿するためのフォー
  マットの一つです。様々なアプリケーションで使われていることもあり、こ
  の形式でツイートをコピーできると何かと便利です。
  このセクションでは、
</p>
<ul>
<li>ユーザが選択して呼び出せる任意の機能(mikutterコマンド)の追加方法
</li>
<li>ツイートの情報(Message)とユーザ情報(User)のオブジェクトの取扱方
</li>
</ul>


<p>
  について解説します。
</p>

</div>

<div id="outline-container-5-1" class="outline-3">
<h3 id="sec-5-1"><span class="section-number-3">5.1</span> コード</h3>
<div class="outline-text-3" id="text-5-1">




<pre class="example"># -*- coding: utf-8 -*-

Plugin.create(:copy_as_stot) do

  command(:copy_as_stot,
    name: 'STOT形式でコピー',
    condition: Plugin::Command[:HasOneMessage],
    visible: true,
    role: :timeline) do
      message = opt.messages.first
      screen_name = message.user[:idname]
      Gtk::Clipboard.copy("#{screen_name}: #{message.to_s} [https://twitter.com/#{screen_name}/status/#{message.id}]")
  end

end
</pre>

</div>

</div>

<div id="outline-container-5-2" class="outline-3">
<h3 id="sec-5-2"><span class="section-number-3">5.2</span> 解説</h3>
<div class="outline-text-3" id="text-5-2">


</div>

<div id="outline-container-5-2-1" class="outline-4">
<h4 id="sec-5-2-1"><span class="section-number-4">5.2.1</span> STOTについて</h4>
<div class="outline-text-4" id="text-5-2-1">

<p>    まずはじめに、STOTの一例を示します。
</p>
<pre class="example">
toshi_a: 会社でふぁぼるのたのしい [http://twitter.com/#!/toshi_a/status/151947400691449856]
</pre>


<p>
    こんなふうに、ユーザのscreen_nameと本文、URL(ツイートのID)の３つの
    要素が含まれています。要は、この３つの要素だけ取得して、クリップボー
    ドに合成したテキストを送れば終わりです。
</p>
</div>

</div>

<div id="outline-container-5-2-2" class="outline-4">
<h4 id="sec-5-2-2"><span class="section-number-4">5.2.2</span> mikutterコマンド</h4>
<div class="outline-text-4" id="text-5-2-2">

<p>    この機能の呼び出し方法ですが、
</p>
<ul>
<li>ツイートを右クリックしたときに出るメニュー
</li>
<li>ツイートを選択した状態で設定されたショートカットキーを押したとき
      に実行される
</li>
</ul>


<p>
    の2つ方法で呼び出せるようにします。mikutterを使っていれば気づくか
    と思いますが、右クリックメニューで選択できる項目はすべてショートカッ
    トキーに割り当てることができます。これは、どちらも登録された
    「mikutterコマンド」を参照しているからで、ここに一つ機能を追加する
    ようにしておけば、ユーザは右クリックメニューから使ったり、ショート
    カットキーに割り当てたり、好きに使うことができます。
</p>
<ul>
<li id="sec-5-2-2-1">commandメソッド<br/>
<ul>
<li id="sec-5-2-2-1-1">commandメソッドの引数<br/>
      commandの第一引数には、コマンドの識別名(slug)を渡します。今回のプラグインのような、
      コマンドを一つだけ提供するのが目的である場合は、プラグインスラッグと同じにする人が多いようです。
      しかし、ある程度の規模のプラグインで、複数のmikutterコマンドを提供する場合は、
      分かりやすいスラッグにしておきましょう。

<p>
      第二匹数は Hash を渡します。以下の様なキーがあります。
</p>
<ol>
<li><b>name</b>
         表示名。コンテキストメニューに表示される内容。String。

</li>
<li><b>description</b>
         この機能の説明など。省略可能。

</li>
<li><b>icon</b>
         アイコンがあれば。Gdk::PixbufとかString(ファイル名)を指定しましょう。
         アイコンを指定しておくと、設定画面や右クリックメニューでそのアイコンが表示されます。
         また、ツールバーには、アイコンがないと表示されません。

</li>
<li><b>condition</b>
         実行条件。これの値と===で引数（後述）が比較されます。引数にもよりますが、Proc、Regexp、Stringなどを指定できます。

</li>
<li><b>visible</b>
         コンテキストメニューに表示するかどうかのフラグ。falseなら表示されない。
         これは例えば、「ひとつ上のつぶやきを選択」のように、右クリックメニューに表示する必要のないものに使う。

</li>
<li><b>role</b>
         コマンドを実行できる環境。たとえば、タイムラインが右クリックすると、ここに <b>:timeline</b> が指定されていて、
         かつ <b>:condition</b> がtrueなものだけが実行又はコンテキストメニューに表示される。指定できるもののバリエーションは後述。
</li>
</ol>


<p>
      <b>role</b> と <b>condition</b> が条件を満たして、ユーザに入力によって実行されることになったら、
      commandメソッドに渡したブロックが実行されます。ブロックは、 <b>condition</b> と同じ引数を受け取ります。
</p>
</li>
</ul>
<ul>
<li id="sec-5-2-2-1-2">コマンドロール<br/>
      あるmikutterコマンドが実行できるウィジェットのことをロール(role)といいます。
      タイムラインや、投稿ウィジェットなど、どこで呼び出されたら実行できるかを設定しておく必要があります。

<ol>
<li>timeline
<dl>
<dt>右クリック</dt><dd>タイムラインを右クリックした時
</dd>
<dt>キーボード</dt><dd>タイムラインにフォーカスがあっている時
</dd>
</dl>

<p>         ツイートが表示されているタイムラインです。 <b>condition</b> の引数の :messages キーに、
         選択されているすべてのツイートが配列で入ります。
         TABキーなどでフォーカスインした時にショートカットキーを押す等、
         ツイートが選択されずにコマンドが実行された場合は空の配列になります。
</p>
<p>
         ツイートによって動作を変更するコマンドはこのロールです。ほとんどのコマンドは、
         これを使うことになるでしょう。
</p>
</li>
<li>tab
<dl>
<dt>右クリック</dt><dd>タブバーのアイコンを右クリックした時
</dd>
<dt>キーボード</dt><dd>タイムラインなど、タブの子ウィジェットにフォーカスがあるとき
</dd>
<dt>ツールバー</dt><dd>タブの内部の一番上
</dd>
</dl>

<p>         タブです。timelineはツイートに対するコマンドという感じですが、tabはタブ全体に影響をおよぼすようなコマンドに使用します。
</p>
<p>
         標準では、「タブを閉じる」や、「新規ペインへ移動」などがこのロールを使用しています。
</p>
</li>
<li>pane
<dl>
<dt>右クリック</dt><dd>なし
</dd>
<dt>キーボード</dt><dd>ペインに所属するウィジェット(具体的にはタブ)にフォーカスがあるとき
</dd>
</dl>

<p>         ペインです。ペインはいくつかのタブの集合体で、ウィンドウ内に横に並べられています。
         アクティブなペインを操作するような、UI関連のコマンドでしか使わないでしょう。
         最も使用頻度は低いと思われます。
</p>
<p>
         標準では、「左(右)のペインを選択」で使われています。
</p>
</li>
<li>postbox
<dl>
<dt>右クリック</dt><dd>なし
</dd>
<dt>キーボード</dt><dd>Postbox上でキーボード入力をした時

</dd>
</dl>

<p>         Postbox(ツイート投稿ウィジェット)です。ユーザがキーをタイプするたびにコマンドを実行します。
         一つ注意することは、実行するコマンドがあれば、タイプされた文字は入力されないということです。
         例えば、fに「カーソルを右へ移動」のような機能を割り当てると、fを入力できなくなります。
         このことによって、Enterに投稿を割り当てることもできます。
</p>
<p>
         標準では、「投稿する」で使われています。
</p>
</li>
<li>window
<dl>
<dt>右クリック</dt><dd>なし
</dd>
<dt>キーボード</dt><dd>mikutterのウィンドウがアクティブなとき
</dd>
<dt>ツールバー</dt><dd>ステータスバーの右下 (0.2.1で未実装)
</dd>
</dl>

<p>         ウィンドウです。どこでも実行できるようなコマンドに設定します。まだ実装が完全に終わっておらず、
         想定外の動作を刷ることがあるかもしれません。mikutter 0.2.1では、まだ使用されていません。
</p>
<p>
         今後、「設定」や「コンソールを開く」などが、このロールを使う予定です。
</p></li>
</ol>


<p>
      実は、この他にもプロフィール関連のロールがあるのですが、それはプロフィール拡張プラグインを書くときに説明したいと思います。
</p>
</li>
</ul>
<ul>
<li id="sec-5-2-2-1-3">コールバックの引数<br/>
      <b>condition</b> に指定された無名関数や実行ブロックには、以下の様な構造体が渡されます。




<pre class="example">Plugin::GUI::Event = Struct.new(:event, :widget, :messages)
</pre>


<dl>
<dt>:event</dt><dd>イベント呼び出し元。標準では、 :keyboard か :contextmenu か :toolbar
</dd>
<dt>:widget</dt><dd>入力を受け取ったウィジェット。例えばtimelineロールなら必ずタイムラインのインスタンス。
</dd>
<dt>:messages</dt><dd>タイムラインに入力があった場合、イベントが発生した時選択されていたツイート。
                     複数選択されていることがあるので、1つしか選択されてなくても配列。
                     何も選択されてなければ空の配列。
</dd>
</dl>


</li>
</ul>
</li>
</ul>
</div>
</div>
</div>

</div>

<div id="outline-container-6" class="outline-2">
<h2 id="sec-6"><span class="section-number-2">6</span> システムメッセージの利用</h2>
<div class="outline-text-2" id="text-6">

<p>  mikutterを使っていると、mikutter_botというアカウントのツイートとしてシステムメッセージがホームTLに入ることがあります。
  このセクションでは、このメッセージをプラグインから表示して、ユーザに情報を提示する方法と、フィルタリングする手段について学習します。
</p>

</div>

<div id="outline-container-6-1" class="outline-3">
<h3 id="sec-6-1"><span class="section-number-3">6.1</span> コード</h3>
<div class="outline-text-3" id="text-6-1">




<pre class="example"># -*- coding: utf-8 -*-

Plugin.create(:time_signal) do

  defactivity "hour_signal", "時報"

  now = Time.new
  time = Time.mktime now.year, now.mon, now.day, now.hour

  def next_hour(time)
    time += 3600
    notice "next hour #{time}"
    Reserver.new(time) {
      activity :hour_signal, "#{time.hour} 時です"
      next_hour(time)
    }
  end
  next_hour(time)
end

</pre>

</div>

</div>

<div id="outline-container-6-2" class="outline-3">
<h3 id="sec-6-2"><span class="section-number-3">6.2</span> 解説</h3>
<div class="outline-text-3" id="text-6-2">


</div>

<div id="outline-container-6-2-1" class="outline-4">
<h4 id="sec-6-2-1"><span class="section-number-4">6.2.1</span> アクティビティとは</h4>
<div class="outline-text-4" id="text-6-2-1">

<p>    アクティビティは、mikutter 0.2から追加された仕組みで、mikutter上やTwitter上で起こった通知情報を統合管理する仕組みです。
</p>
<p>
    <img src="activity.png"  alt="activity.png" />
</p>
<p>
    まず、何らかのプラグインがactivityメソッドを使って通知を発生させます。その通知はactivityプラグインが受け取り、 <b>:modify_activity</b> というイベントを発生させます。このイベントを受け取って、ホームTLやアクティビティタブに通知が表示されるのです。
</p>
</div>

</div>

<div id="outline-container-6-2-2" class="outline-4">
<h4 id="sec-6-2-2"><span class="section-number-4">6.2.2</span> 通知の種類</h4>
<div class="outline-text-4" id="text-6-2-2">

<p>    通知には、お気に入りとかDMとか、はたまたエラー通知とか、種類があります。今回は時報のための <b>hour_signal</b> という通知を定義しています。
</p>
<pre class="example">
defactivity "hour_signal", "時報"
</pre>


<p>
    とはいっても、普通は最初から用意されている system という種類の通知を使うので、その場合は <b>defactivity</b> を使う必要はないです。
</p>
</div>

</div>

<div id="outline-container-6-2-3" class="outline-4">
<h4 id="sec-6-2-3"><span class="section-number-4">6.2.3</span> 実際に通知を発生させる</h4>
<div class="outline-text-4" id="text-6-2-3">

<p>    通知を発生させるのはごく簡単です。例のコードでは、以下の部分です。
</p>
<pre class="example">
activity :hour_signal, "#{time.hour} 時です"
</pre>


<p>
    これで、「x 時です」と、毎時間通知されるようになります。しかしこのプラグインを実際に使うと、タイムラインには表示されず、アクティビティタブにしか表示されません。理由は簡単で、「設定」の「アクティビティ」で、時報をTLに表示する設定がデフォルトで無効になっているからです。設定でこのチェックを入れるとTLに表示されるようになります。
</p>
<p>
    どうしてもホームTLに表示したい場合があるでしょう。その場合、Plugin.callで無理やりシステムメッセージを挿入する古い方法の代わりに、 <b>system</b> 通知を使いましょう。これは、種類を分けるまでもない一般的なシステムメッセージのために予約されており、デフォルトでTLに表示されるようになっています。もちろんユーザがTLに表示しないように設定できるので、プラグインがアクティビティの仕組みを使えば、ユーザは通知をミュートすることができます。
</p>
</div>
</div>
</div>

</div>

<div id="outline-container-7" class="outline-2">
<h2 id="sec-7"><span class="section-number-2">7</span> 終わりに</h2>
<div class="outline-text-2" id="text-7">

<p>   mikutterは、ほとんどすべての機能がプラグインで実装されていることからも分かる通り、プラグインで柔軟に機能が追加できるようになっています。
   今回は、いくつかの簡単なプラグインを実装する方法を紹介しました。これらを組み合わせれば、ある程度いろんなプラグインを作成できるでしょう。
</p>

</div>

<div id="outline-container-7-1" class="outline-3">
<h3 id="sec-7-1"><span class="section-number-3">7.1</span> プラグインを公開する</h3>
<div class="outline-text-3" id="text-7-1">

<p>   作ったプラグインを公開すれば、他の人がmikutterでその機能を利用できるようになります。mikutterでは、githubにプラグインを公開することを推奨しており、現に多くのプラグインはgithubに公開されています。
</p>
<p>
   プラグインを管理するプラグインも現在開発が進んでいます。<a href="https://github.com/toshia/mikustore">みっくストア</a> です。これはまだ始まったばかりのプロジェクトで十分な機能はありませんが、うまく行けばmikutter上でプラグインのダウンロード・インストールが可能になるでしょう。現在既に、自分のストアを公開できるようになっています。
</p>
<p>
   また、<a href="http://yuzuki.hachune.net/wiki/FrontPage">mikutter wiki</a>にもあなたの公開したプラグインを掲載してみましょう。mikutter wikiは、現在唯一機能しているプラグインリストです。githubだけでは、mikutterプラグインをだらだら眺めることができないので、気づいてもらえないかもしれません。
</p>
</div>

</div>

<div id="outline-container-7-2" class="outline-3">
<h3 id="sec-7-2"><span class="section-number-3">7.2</span> 他のドキュメント</h3>
<div class="outline-text-3" id="text-7-2">

<p>   mikutterは常に進化しており、このドキュメントも追随はしていますが、個々に書いていることが全てではありません。最後に、プラグインを書く上で参考になる資料をいくつか紹介しておきます。
</p>
<p>  
   RDoc <a href="http://mikutter.hachune.net/rdoc/index.html">http://mikutter.hachune.net/rdoc/index.html</a> を見れば、開発版で、どういったクラスやメソッドが使用できるか確認することができます。
   完璧ではありませんが、主要なものや最近書かれたものについては、ドキュメントが存在します。
</p>
<p>
   Redmine <a href="http://dev.mikutter.hachune.net/">http://dev.mikutter.hachune.net/</a> を参照すれば、最近どんな変更が加わったのかを知ることができますし、あなたが発見したバグを報告することもできます。
</p>
<p>
   mikutter開発日記 <a href="http://mikutter.blogspot.com/">http://mikutter.blogspot.com/</a> は、ある程度まとまった情報を取得するのに便利です。
</p>
<p>
   最後に、「Writing mikutter plugin」の最新版は、 <a href="https://github.com/toshia/writing-mikutter-plugin">https://github.com/toshia/writing-mikutter-plugin</a> に公開されています。
   最新バージョンに対応していますし、冒頭にも書いたとおり、サンプルコードを取得することも出来ます。
</p></div>
</div>
</div>
</div>

<div id="postamble">
<p class="date">Date: </p>
<p class="author">Author: @toshi_a</p>
<p class="creator"><a href="http://orgmode.org">Org</a> version 7.9.3f with <a href="http://www.gnu.org/software/emacs/">Emacs</a> version 24</p>
<a href="http://validator.w3.org/check?uri=referer">Validate XHTML 1.0</a>

</div>
</body>
</html>
