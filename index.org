#+TITLE: Writing mikutter plugin
#+AUTHOR: @toshi_a
#+OPTIONS: ^:nil
#+DATE:
#+LATEX_CLASS: resume

* はじめに
  Rubyでmikutterを拡張する方法についてです。

  mikutterはサードパーティの「プラグイン」を追加して、あとから機能を追
  加することができます。

  本文章では、いくつかの事例を取り上げて、プラグインを作るための大まかな方
  法を説明します。

  サンプルコードは、 https://github.com/toshia/writing-mikutter-plugin にこのドキュメントの最新版があるので、そこから取得してください。

** 想定する読者
   一応、これを読むような人は大抵プログラミングの経験があると思いますが、何らかの言語を理解している人なら、Rubyを勉強しながら簡単にプラグインを書くことができると思います。
   基本的なプログラミングの概念については説明していません。世の中にはRubyでプログラミングを学ぶことができる文献がいくつもありますので、プログラミング自体の話はそういうのをどうぞ。

** プラグインの動かし方
   mikutterのプラグインをインストールするには、 ~/.mikutter/plugin の直下に拡張子 *.rb* で終わるファイルを置くか、
   プラグイン名のディレクトリを作成し、その中に *プラグイン名.rb* という名前のファイルを設置する方法があります。
   後者の方法を使うと、gitなどでプラグインごとにバージョン管理が容易になりますし、プラグイン自体を複数のファイルに分割することができます。

** プラグインの作成支援機能
   mikutterにはプラグインの作成を支援する機能があります。mikutter.rbにはいくつかのコマンドラインオプションがあります。

   : $ mikutter.rb --help
   : command are:
   :     generate [plugin_slug]       generate plugin template at ~/.mikutter/plugin/
   :     spec [directory]             generate plugin spec. ex) mikutter spec ~/.mikutter/plugin/test

*** 雛形の作成(generate)
    プラグインを新しく作成するときに、以下の様なコマンドを実行すれば必要なディレクトリを作成し、ひな形ファイルを作成します。

    : $ mikutter.rb generate test_plugin

    これで、 ~/.mikutter/plugin/test_plugin/ ディレクトリが作成され、その中に test_plugin.rb というファイルが作成されます。また、このファイルには最低限のプラグインのテンプレートが書かれています。

#+BEGIN_SRC ruby
# -*- coding: utf-8 -*-

Plugin.create(:test_plugin) do

end
#+END_SRC

*** 定義ファイルの作成(spec)
    mikutter 0.2からはプラグインに定義ファイルを持たせることが推奨されています。定義ファイルは、プラグインの説明、バージョン、作者、依存関係などの情報を含むファイルで、なければ不適切な環境でプラグインがロードされ、クラッシュするおそれがあります。書式を長々と説明するよりも、これも自動的に生成させることができます。

    : $ mikutter.rb spec ~/.mikutter/plugin/test_plugin/

    引数には、プラグインのスラッグではなく、ディレクトリパスを与えることに注意してください。これを実行すると、対話的に２，３質問されるので、適当に答えましょう。すると、 ~/.mikutter/plugin/test_plugin/spec というファイルが生成されるはずです。
    test_pluginは何も内容がないので、specファイルも見所がありません。みっくストア([[https://github.com/toshia/mikustore]])のspecファイルがこの方法で生成されているので、ちょっと見てみましょう。

#+BEGIN_SRC yaml
---
slug: :mikustore
depends:
  mikutter: 0.2.0.1051
  plugin:
  - settings
version: '0.1'
author: toshi_a
name: みっくストア
description: mikutterにプラグインのパッケージ管理機能を追加します。みっくストアに登録されているプラグインはクリックだけでダウンロードできます！
#+END_SRC

     適切な情報が自動的にspecファイルに書き込まれました。もう一度、specファイルを作成するコマンドを実行してみましょう。今度は何も聞かれずにすぐにコマンドが終了してしまったはずです。というのも、対話プロンプトで入力されるような内容は、既に存在するspecファイルに書かれているからです。二度目以降は、依存関係などを更新するだけとなります。

** 準備はできた？
   プラグインを作成する準備は整いました。早速、いくつかのサンプルプラグインを見ながら、お気に入りのエディタを起動して、mikutterをハックしましょう。

* 特定の時間にツイートする
  このセクションでは、特定の時間に定型文をツイートする、botのようなプラグインを作成します。
** コード
   #+BEGIN_SRC ruby
# -*- coding: utf-8 -*-
# say "よるほー"
# よるほーの例です。あくまでReserverのデモンストレーション用に作りました。
# なので実戦投入はしないこと。よるほーは自分でタイミングを合わせることにこそ意義があるのです。

Plugin.create :yoruho do
  def main
    Reserver.new(nextyrhtime){
      say_yoruho(Service.primary)
      sleep 1
      main } end

  # 次回のよるほー時間を取得
  def nextyrhtime
    now = Time.new
    result = Time.local(now.year, now.month, now.day, 0, 0)
    while result < now
      result += 86400 end
    result end

  # よるほーとつぶやく
  def say_yoruho(service)
    service.update(:message => 'ておほー') end

  main
end
#+END_SRC

** 解説
   ほぼすべてのプラグインは、以下のテンプレートから作り始めることになります。

   : Plugin.create :プラグイン名 do
   :   (プラグインの定義)
   : end

   Plugin.create は、プラグインをコアに登録します。また、ブロック内でプラグインを実装するための様々なメソッドを提供しています。
   この中で変数や関数を定義すれば外のスコープも汚さないので、基本的にはこのブロックの中だけでプラグインは完結させるべきです。

*** メソッドの定義
    ブロックの中は、すぐにPluginのインスタンスの中で評価されます。defで
    メソッドを定義して、メソッドの内外で呼ぶことができます。例では main
    と next_yrh_time と say_yoruho を定義していますね。

*** 文字列を投稿する
**** Serviceオブジェクト
     自動投稿を実現するためには、Serviceクラスのインスタンスを得ます。
     Serviceクラスは、Twitter APIのラッパで、ログインしているTwitterアカウ
     ントの数だけインスタンスがあります。なので、プラグインがこのクラス
     をnewすることはありません。

     これを書いている現在では、mikutterは１つのアカウントでしかサインアッ
     プできないということになっているので、以下のように書けば、Serviceクラ
     スを得ることができると覚えておいてください。

     : Service.primary

     mikutterはそのうち複垢対応しますが、そうなったらこのメソッドは、現
     在アクティブな(選択されている)アカウントのServiceを返します。

**** update
     Service#update で、ツイートが投稿されます。

     : Service.primary.update(:message => "ツイートの本文")

     ツイートの投稿は非同期で行われるので、処理がここで止まるというこ
     とはありません。

*** Reserver 予約実行
    特定の時間に処理を実行したいことがあります。今回の場合だと、毎日
    0:00:00に、よるほーとつぶやくコードを実行したいわけです。そういう
    時は、mikutterが提供しているReserverを使います。

    String, Time, Integerのいずれかの値を渡します。

    Stringの場合はTime.parse()された値が使われ、Timeを渡すと、その時刻
    になったら実行します。過去の時刻を渡すとすぐに実行されます。

    : Reserver.new("10:00"){ 朝10時に実行 }

    Integerの場合は、その秒数待ってから実行します。

    : Reserver.new(30){ 30秒後に実行 }
    : Reserver.new(HYDE){ 156秒後に実行 }

    今のところ、Reserverのブロックは、メインスレッド以外のスレッドで実
    行されます。非同期処理によるバグには気をつけてください。

* 特殊なタイムライン
  現在のmikutterのUIは、以下のような構成です。

  file:window-hierarchy.png

  ウィンドウが一つ有り、その中にユーザは任意の個数のペインを作ります。
  ペインの中には１つ以上のタブがあり、タブの中身はプラグイン次第です
  が、基本的にはタイムラインが入っているはずです。

  このセクションでは、特殊な抽出条件を持ったタイムラインを作成します。
  タイムラインを用いたあらゆるプラグインに応用できる知識です。

** コード
   
#+BEGIN_SRC ruby
# -*- coding: utf-8 -*-
# mikutterについてフォロイーが言及したら、しばらくTLに入れる

Plugin.create :gossip_detector do

  EXPIRE = 300                  # 5 min

  main = Gtk::TimeLine.new()
  gossip_users = {}

  # TLタブの登録
  onboot do |service|
    Plugin.call(:mui_tab_regist, main, 'Gossip Detector', MUI::Skin.get("timeline.png"))
  end

  # ツイートの受信、振り分け
  onupdate do |service, messages|
    main.add message.select { |m|
      if m.to_s =~ /mikutter|みくった/
        gossip_users[m.user] = Time.now + EXPIRE
        true
      else
        gossip_users.has_key?(m.user) and gossip_users[m.user] > m[:created]
      end
    }
  end

end

#+END_SRC

** 解説
   このプラグインは、タイムラインをひとつ作って、フォロイーが mikutter に
   ついて何か言及したら、そのツイートをそのタイムラインにも表示します。
   これだけだと、現在 mikutter に標準で入っている extract plugin と同じで
   すが、このプラグインはその人のツイートを、マッチしたツイートから5分間
   の間は、無条件にタイムラインに入れます。

   最初に mikutter の名前を出して、あとでツイートを小分けにして mikutter
   について言及しているかもしれないからです。そんなことないかもしれませんが、こんな変なフィルタも書けるんだよというデモなので勘弁して下さい。

*** イベントの待受
    ユーザやTwitterから何かしらの入力があれば、mikutter内ではイベントが発
    生します。ほとんどのプラグインは、このイベントを受け取って何かを実行す
    ることで、目的を達成します。
    Plugin.create のブロック内に、以下のように書けば、イベント *event* が
    発生したときに *処理* が実行されます。その際、引数は *params* にセット
    されます。

#+BEGIN_SRC ruby
    onevent do |params|
      # 処理
    end
#+END_SRC

    *onevent* は、 *on_event* と書いても *event* を待ち受けます。イベ
    ント名が長いなど、つなげて書くと読みづらい場合は、間にアンダーバー
    を入れるパターンを使ってもいいかもしれません。
    引数は、イベントによって異なります。 mikutter プラグインの開発にとって
    イベントはとても重要なものですが、数が多いので、このあと出てくるぶんに
    ついても逐一解説はしません。各イベントについて知りたい場合は、RDocの
    イベント・フィルタリファレンス http://mikutter.hachune.net/rdoc/Plugin.html を参照してください。ただし、これが
    mikutterのすべてのイベントを網羅しているわけではありません。プラグ
    インが新しい種類のイベントを定義することができるからです。

*** タイムライン
    タイムラインをタブに登録するには、タイムラインウィジェットを作成し、
    それをGUIプラグインに渡してやる必要があります。

**** タイムラインウィジェット
     タイムラインウィジェットを作成するのは簡単です。以下のように書き
     ます。

#+BEGIN_SRC ruby
     timeline = Gtk::TimeLine.new
#+END_SRC

     これで、表示するタイムラインの準備が出来ました。

**** イベントを発生させる
     タイムラインウィジェットは、確保したあとGUIプラグインに送らないと
     表示されません。GUIプラグインにウィジェットを送るためには、
     *mui_tab_regist* イベントを発生させてやる必要があります。

     GUIプラグインは、 *mui_tab_regist* イベントを監視していて、イベン
     トが発生したら引数のタイムラインウィジェットをペインに追加するよ
     うになっています。

#+BEGIN_SRC ruby
     timeline = Gtk::TimeLine.new
     Plugin.call(:mui_tab_regist, timeline, 'Title', MUI::Skin.get("timeline.png"))
#+END_SRC

     Plugin.call() は、イベントを発生させるためのメソッドです。第一引
     数のイベントを発生させ、第二引数以降は、イベントの引数です。この
     メソッドは即座に返ってきて、実際のイベントの起動は、あとで処理の
     手が空いたときに行われます。

     今回の範囲からは逸脱しますが、イベントを発生させる時、待ち受けるブ
     ロックを登録するときには、そのイベントが存在するかどうかは確認しま
     せん。つまり、プラグインが好きにイベントを作成することができる、と
     いうことです。この仕組を用いて、あなたの作成したプラグイン同士がイ
     ベントを使って通信することができますし、本来は別のプラグイン同士が
     通信する内容を受け取ることも出来ます。今回の *mui_tab_regist* は、
     GUIプラグインが独自に提供しているイベントです。

***** タブのアイコン
      例の中で使っている MUI::Skin.get() について、一応解説しておきま
      す。

      これは、タイムラインのアイコンのパスを返します。省略可能ですが、
      このように指定しておけば、ホームタイムラインと同じアイコンが表示
      されます。スキン機能が実装されたら、現在のスキンでのアイコンの絶
      対パスを返すようになりますが、現在は実装されていないので、デフォ
      ルトスキンの絶対パスを返しています。

**** タイムラインにツイートを追加する
     作成したタイムラインを表示することは出来ました。次に、ツイートを
     タイムラインに追加する方法です。これは簡単です。

#+BEGIN_SRC ruby
     timeline.add(Message...)
#+END_SRC

     Gtk::TimeLine#add にMessageのインスタンスか、それが入っ
     た配列を渡せば追加されます。

     Messageについては、結構複雑なので後述します。今回の例では、 
     Message#user を使って、ツイートしたユーザを取得しているのと、
     Message#[] の *:created* (投稿日時)を取得しています。

     この情報を元に、mikutterの言及があれば今後5分間だけツイートを抽出
     するフィルタを実現できるわけです。
     少し実装を変えれば、他のツイッタークライアントではできないような
     複雑なフィルタを比較的簡単に実装することができるでしょう。

* スマートなミュート機能
  mikutter標準のミュート機能は、すべてのタイムラインからツイートを非表
  示にします。このセクションでは、イベントが発生する前にその内容を編集・
  削除するためのイベントフィルタ機能、またそれを単体で使って、プラグイ
  ン間通信を実現する方法について解説します。

** コード
   今回は、特定の単語の入ったツイートを非表示にします。
   #+BEGIN_SRC ruby
# -*- coding: utf-8 -*-

Plugin.create(:mute_word) do

  exclude_words = ["政治","原発"] # フィルタする単語

  filter_show_filter do |msgs|
    msgs = msgs.select{ |m| not exclude_words.any?{ |word| m.to_s.include?(word) } }  end
    [msgs]
  end

end
   #+END_SRC

** 解説
*** イベントフィルタ
**** イベントの引数を編集する
     ツイートをプラグインに配送するためにイベントが使われることは前のセ
     クションで触れました。今回は、イベントの発生時にそれを捕まえて、引
     数を書き換えることができる「イベントフィルタ」を使用します。

     フィルタは、Plugin.createのブロック内で以下のように宣言します。

     #+BEGIN_SRC ruby
     filter_update do |service, msgs|
       msgs = msgs.select{ |m| not m.to_s.include?("政治") }
       [service, msgs]
     end
     #+END_SRC

     イベントが発生すると、イベントと同じ名前のフィルタが登録されていな
     いか確認して、登録されていたら先にフィルタを実行し、その戻り値を新
     たに引数リストにします。なので、普通のイベントと同じように引数を受
     け取り、加工した結果を返すことで、イベントの引数を変更できます。

     この場合は、updateイベントで配送されるツイートをすべて確認して、
     「政治」「原発」というキーワードが含まれたツイートを削除します。
     三行目が戻り値ですが、ここに注目してください。引数を配列で返してい
     ます。こうやって、加工した値を返してやることで、実際にイベントが発
     生する時には、該当するツイートが除外されるようになるわけです。

     一つ注意しなければいけないのは、戻り値の配列は、必ず引数の数と一
     致しなければいけないということです。なぜなら、イベントの引数の数
     は、今のところ常に固定だからです。

**** イベントフィルタを使ったプラグイン間の通信
     イベントを使えば、別のプラグインに情報を伝えることができるという
     のは前に紹介したとおりです。

     しかし、イベントは受け取りたい方がイベントを待ち受けて、発信されるのを待つ必要があります。
     実際には受け取り側のリクエストに即座に答えるような通信をしたいことのほうが多いと思われますが、
     こういった用途にもイベントフィルタを使用します。

     まず、イベントフィルタは、イベントが発生していなくても、単独で呼び出すことができます。

     : Plugin.filtering(:update, Post.primary_service, [Instance of Messages...])

     この戻り値は、[Post, [Message...]]のような、イベントフィルタの戻
     り値そのままです。

     次に、イベントフィルタは、イベントが未定義でも作成できます。

     #+BEGIN_SRC ruby
     filter_plus do |num|
       [num + 1]
     end
     #+END_SRC

     つまり、直接呼び出されることだけを想定したフィルタを勝手に定義し
     てしまえば、リクエスト-レスポンス型の通信が実現できるのです。

***** mikutterから完全に排除するには
      実は、updateイベントのフィルタでは、ホームタイムラインから表示さ
      れなく成るだけで、他のタイムラインからはフィルタリングできていま
      せん。この実装のほうがいい場合もあるでしょうが、mikutter上にそも
      そも表示されないようにしたい場合もあると思います。

      そのためには、タイムラインが表示前にフィルタを呼び出していれば、
      そこで削除することができますね。当然、mikutterはミュートを実現す
      るために、表示する寸前に以下のようなコードでフィルタを呼び出して
      います。

      : Plugin.filtering(:show_filter, message)

      つまり、前に書いたupdateフィルタは以下のように書き換えれば、すべ
      てのタイムラインに影響するようになります。

      #+BEGIN_SRC ruby
      filter_show_filter do |msgs|
        msgs = msgs.select{ |m| not m.to_s.include?("政治") }
        [msgs]
      end
      #+END_SRC

      show_filterは、notifyプラグインからも使用されていて、TLに表示さ
      れないツイートはポップアップ通知や効果音も鳴らさないようになって
      います。こんなふうに、他のプラグインが他の用途のためのフィルタを
      使用したり、コールバックを登録することもできます。イベントとフィ
      ルタをうまく使えば、プラグインそれ自身に拡張性を持たせることがで
      きます。

* STOT形式でコピー
  STOT(ShareTwitterOnTumblr)は、ツイートをTumblrに投稿するためのフォー
  マットの一つです。様々なアプリケーションで使われていることもあり、こ
  の形式でツイートをコピーできると何かと便利です。
  このセクションでは、

  - ユーザが選択して呼び出せる任意の機能(mikutterコマンド)の追加方法
  - ツイートの情報(Message)とユーザ情報(User)のオブジェクトの取扱方

  について解説します。

** コード
   #+BEGIN_SRC ruby
# -*- coding: utf-8 -*-

Plugin.create(:copy_as_stot) do

  filter_command do |menu|
    menu[:copy_as_stot] = {
      :slug => :copy_as_stot,
      :name => 'STOT形式でコピー',
      :condition => lambda{ |opt|
        true
      },
      :exec => lambda{ |opt|
        message = opt.message
        screen_name = message.user[:idname]
        Gtk::Clipboard.copy("#{screen_name}: #{message.to_s} [http://twitter.com/#!/#{screen_name}/status/#{message.id}]")
      },
      :visible => true,
      :role => :message }
    [menu]
  end

end
   #+END_SRC
** 解説
*** STOTについて
    まずはじめに、STOTの一例を示します。

    : toshi_a: 会社でふぁぼるのたのしい [http://twitter.com/#!/toshi_a/status/151947400691449856]

    こんなふうに、ユーザのscreen_nameと本文、URL(ツイートのID)の３つの
    要素が含まれています。要は、この３つの要素だけ取得して、クリップボー
    ドに合成したテキストを送れば終わりです。

*** mikutterコマンド
    この機能の呼び出し方法ですが、

    - ツイートを右クリックしたときに出るメニュー
    - ツイートを選択した状態で設定されたショートカットキーを押したとき
      に実行される

    の2つ方法で呼び出せるようにします。mikutterを使っていれば気づくか
    と思いますが、右クリックメニューで選択できる項目はすべてショートカッ
    トキーに割り当てることができます。これは、どちらも登録された
    「mikutterコマンド」を参照しているからで、ここに一つ機能を追加する
    ようにしておけば、ユーザは右クリックメニューから使ったり、ショート
    カットキーに割り当てたり、好きに使うことができます。

    サンプルコードでいうと、menuという連想配列に入れる内容がポイントです。
    以下のキーを持ったハッシュを入れます。

    1. *slug*
       コマンドスラッグ。一意なコマンド名。Symbol。

    2. *name*
       表示名。コンテキストメニューに表示される内容。String。

    3. *description*
       この機能の説明など。省略可能。
    4. *icon*
       アイコンがあれば。今のところ使われない。Gdk::PixbufとかString(ファイル名)を指定しましょう。

    5. *condition*
       実行条件。これの値と===で引数（後述）が比較されます。引数にもよりますが、Proc、Regexp、Stringなどを指定できます。

    6. *exec*
       実行される本体。:conditionと同じ引数を受け取るが、:conditionがfalseになった場合はそもそもこれは呼ばれない。

    7. *visible*
       コンテキストメニューに表示するかどうかのフラグ。falseなら表示されない。
       これは例えば、「ひとつ上のつぶやきを選択」のように、右クリックメニューに表示する必要のないものに使う。

    8. *role*
       コマンドを実行できる環境。たとえば、つぶやきを右クリックすると、ここに:messageが指定されたもののうち、
       :conditionがtrueなものだけが実行又はコンテキストメニューに表示される。指定できるもののバリエーションは後述。
    
    *:condition* や *:exec* の「引数」というのは、 *:role* に何を設定した
    かによって変わります。

    1. *message*
       つぶやきにフォーカスがあるとき。以下のような構造体を引数に呼び
       出されます。
       #+BEGIN_SRC ruby
       Struct.new(
         :event          # Gdk::Event or nil,
         :message        # Message,
         :timeline       # Gtk::TimeLine,
         :miraclepainter # Gdk::MiraclePainter
       )
       #+END_SRC

    2. *messages*
       *message* とほぼ同じだが、ツイートの複数選択に対応しています。
       ツイートの数だけ構造体を含んだ配列が引数として渡されます。

    3. *message_select*
       *message* の時で、なおかつテキストが選択されているとき。引数も同じ。

    4. *timeline*
       タイムラインで右クリックされたとき。基本的に *message* と同じタイミングだけど、引数はGtk::TimeLineしか受け取らないという点がちがう。

    5. *postbox*
       つぶやき入力欄。今のところ、ショートカットキーにしか対応していない。引数としてGtk::PostBoxを受け取ります。

    こういうふうに、わりと簡単にmikutterコマンドを新しく追加できます。
    mikutterコマンドの話については、mikutter開発日記のmikutterコマンド http://mikutter.blogspot.com/2011/05/mikutter.html でも触れています。

*** Message
    次に、前のセクションでも出てきたMessageについて触れます。御存知の
    通りmikutter上で一つのツイートを表すオブジェクトです。
    Messageはプラグインから作ることはまずありません。現在のところ、
    一つのツイートにつき必ず一つだけMessageのインスタンスが生成される
    ことが保証されています。
    実はキャッシュ機能や他のツイートを探索する機能も持っているのですが、
    今回は圧倒的に使用頻度が高いと思われる、ツイートの内容を取得すると
    ころに焦点を絞って紹介します。

**** 用意されているキー

     次のキーで、ツイートの情報の取得はできます。例えば、 *m* に
     Messageのインスタンスが格納されているとしたら、 *m[:id]* で、ツイー
     トのIDが取得できます。

     また、いくつかの情報はインスタンスメソッドでも取得できます。キーを
     指定する方法なら正直に今持っている値を返しますが、メソッドを呼んだ
     場合はできるだけ正確に値を返そうとします。

     例えば、 *m[:reply_to]* は、返信先のツイートが読み込まれていない場
     合はツイートIDを数字で返す可能性がありますが、
     *m.receive_message* は、そういう場合、データベースのキャッシュや、
     場合によってはTwitterサーバにAPIリクエストを発行して返します。

     | キー     | 意味                                 | 他の方法          |
     |----------+--------------------------------------+-------------------|
     | id       | ツイートのID(数字)                   | m.to_i            |
     | entity   | エンティティ情報(後述)               | m.links, m.entity |
     | message  | ツイートの本文                       | m.body            |
     | user     | ツイートを投稿したユーザ(User)       | m.to_user         |
     | receiver | このツイートを宛てられたユーザ(User) | m.receiver        |
     | replyto  | このツイートの返信先のMessage        | m.receive_message |
     | retweet  | これがリツイートなら元のMessage      |                   |
     | source   | 投稿したクライアント情報             |                   |
     | geo      | ジオタグ                             |                   |
     | created  | 投稿時刻                             |                   |
     | modified | 更新時刻                         |                   |
     
     詳しいメソッドの一覧は、[[http://mikutter.hachune.net/rdoc/Message.html][RDocのMessageの項]]を参照してください。

*** User
    UserクラスとMessageクラスはともにRetrieverのサブクラスで、機能はほ
    とんど同じです。ただし、当然持っている情報のキーに違いがあります。

**** 用意されているキー

     | キー              | 意味                                  | 他の方法         |
     |-------------------+---------------------------------------+------------------|
     | id                | ユーザのID(数字)                      | u.to_i           |
     | idname            | スクリーンネーム                      | u.idname, u.to_s |
     | name              | 名前                                |                  |
     | location          | (プロフィールの)現在地                |                  |
     | detail            | プロフィール本文(bio)                 |                  |
     | profile_image_url | アイコン画像のURL                     |                  |
     | url               | Webページ（プロフィールで設定された） |                  |
     | protected         | 非公開ユーザ(鍵垢)なら真              |                  |
     | followers_count   | フォロワーの数                        |                  |
     | statuses_count    | ツイート数                            |                  |
     | friends_count     | フォロイー(フォローしている人)の数    |                  |

     専用メソッドはほとんど用意されていませんが、例えばこのユーザが「自分」
     かどうかを判定する *is_me?* のような便利なメソッドがいくつかあり
     ます。詳細は、[[http://mikutter.hachune.net/rdoc/User.html][RDocのUserの項]]を参照してください。

* あとがき
   mikutterは、ほとんどすべての機能がプラグインで実装されていることからも分かる通り、プラグインで柔軟に機能が追加できるようになっています。
   今回は、４つの例をとおして、簡単なプラグインを実装する方法を紹介しました。これらを組み合わせれば、ある程度いろんなプラグインを作成できるでしょう。

   今まで書いてきた内容も、現在では古くなっている可能性があります。日々進化しつづけるmikutterですが、時にはどうしても後方互換性が取れないような
   変更をしなければいけない時もあるからです。また、今まで冗長だった書き方も、スマートな方法が提供される場合もあります。
   最後に、最新の情報へのポインタを幾つか示しておきます。
  
   RDoc http://mikutter.hachune.net/rdoc/index.html を見れば、trunkで、どういったクラスやメソッドが使用できるか確認することができます。
   完璧ではありませんが、主要なものや最近書かれたものについては、ドキュメントが存在します。

   Redmine http://dev.mikutter.hachune.net/ を参照すれば、最近どんな変更が加わったのかを知ることができます。

   mikutter開発日記 http://mikutter.blogspot.com/ は、ある程度まとまった情報を取得するのに便利です。

   最後に、「Writing mikutter plugin」の最新版は、 https://github.com/toshia/writing-mikutter-plugin に公開されています。
   最新バージョンに対応していますし、冒頭にも書いたとおり、サンプルコードを取得することも出来ます。
